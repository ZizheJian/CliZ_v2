CliZ is an adaptive compressor designed for tensor-structured meteorological data. It includes three executables: cliz_compress, cliz_decompress, and cliz_validate.

Compressing and decompressing a single data file:
1. Use cliz_compress to compress the data. Depending on the parameters, it may generate a .cfg file and a .map file.
2. Use cliz_decompress to decompress the data, using the previously generated .cfg and .map files.
3. (Optional) If the original data is available, use cliz_validate to verify the quality of the compression.

Compressing and decompressing multiple similar data files:
1. Prepare a .cfg file and a .map file using cliz_compress on one of the data files.
2. Use the same .cfg and .map files to compress the remaining data files. These will not generate new .cfg or .map files.
3. Use cliz_decompress to decompress all files using the same .cfg and .map files.
4. (Optional) If the original data is available, use cliz_validate to verify compression quality.

CliZ is mainly written in C. We also provide a starter.py script to simplify the build and execution process. The starter.py script can:
1. Run several code_generation.py scripts to generate C source code (this step is skipped if those scripts haven't changed),
2. Invokes "make -j16" to compile the code,
3. Runs the compression and decompression routines.

Please refer to the comments in starter.py for details on how to use it.

1. Use python to start cliz
Follow the instructions in "starter.py".

2. Use CLI to start cliz compressor
Type "cliz_{job_type} {something}" to start cliz compressor.
{job_type} can be "compress" or "decompress".
{something} includes some of the following arguments:
	A. input file path (necessary)
		-in {input_file_path}
		//E.g. "-in ~/compress/data.bin"
	
	B. output file path (optional)
		-out {output_file_path}
		//If output file is not given, the program will use "{input_file_path}.cliz" as the output file path.

	C. configuration file path (optional)
		//Configuration file contains the information about how data is interpreted and what compression algorithm is used. It can be set in the following form:
		-set-cfg {config_file_path} (only for compressing)
		-use-cfg {config_file_path}
		//During compression, if given "-set-cfg", the program will choose the best algorithm, and store the information in the configuration file.
		//Besides, some other information, including dimensions, data type and error bound will also be stored.
		//If given "-use-cfg", the program will read the given file and use the specified algorithm to compress or decompress.
		//If no command is provided, the program will simply use a cubic interpolation.
	
	D. map file (optional)
		//Map is a table indicating quantization bin classification used in Huffman encoding. It can be set in the following form:
			-set-map {map_file_path} (only for compressing)
			-use-map {map_file_path}
		//During compressing, if given "-set-map", the program will test and decide whether to generate a map file.
		//During compressing, if given "-use-map", the program will use the given map file.
		//During decompressing, if given "-use-map", the program will use the given map file.
		//If given "-use-map", configuration file must be missing or provided with "-use-cfg".
		//If no command is provided, the program will not try this optimization.
	
	E. mask file (optional)
		//Mask file indicates the validness of data on horizontal positions.
		-mask {mask_file_name}
		//The program can get the information about mask file from the command line or the configuration file.
		//If both are available, make sure that they match each other.
	
	F. dimension (optional)
		-dim {dimension_name}{dimansion_length} {dimension_name}{dimension_length} ...
		//Here inputs the dimensions indicating how the data should be interpreted.
		//{dimension_name} indicates the physical meaning of this dimension.
		//Current supported dimension names:
		//	t (time)
		//	h (height)
		//	lat (latitude)
		//	lng (longitude)
		//	/*leave out dimension name*/ (no meaning)
		//E.g. if given "-dim 12 t120 lat180 lng360", data[i0][i1][i2][i3]=data[i0*120*180*360+i1*180*360+i2*360+i3].
		//The program can get the information about dimensions from the command line or the configuration file. At least one of them should be available.
		//If both are available, make sure that they match each other.

	G. data type (optional)
		-type {typename}
		//Here inputs the data type.
		//current supported {typename}:
		//	i32
		//	f32
		//	f64
		//	/*leave out data type*/ (f32)
		//The program can get the information about data type from the command line or the configuration file. If both of them are unavailable, the data type will be set as f32.
		//If both are available, make sure that they match each other.
	
	H. error bound (optional when compressing)
		-err {error_type} {error_bound}
		//Current supported error type:
		//	ABS
		//	REL
		//	LOCAL
		//	/*leave out error type*/ (ABS)
		//{error_bound} should be a value larger or equal to 0.
		//If error bound is 0, cliz generally will convey a naive lossless compression.
		//The program can get the information about error bound from the command line or the configuration file. If both of them are unavailable, the error type will be ABS and error bound will be 0.
		//If both source of information are available, make sure that they match each other.
		//If no configuration file is given, {error_type} must be ABS.
	
	I. intermediate result display (optional)
		-debug
		//This is a flag indicating whether cliz will output some additional file containing some intermediate results.
		//If omited, the program won't generate these additional file.

3. Use CLI to start cliz validator
Type "cliz_validate {something}" to start cliz validator.
{something} includes some of the following arguments:
	A. source file path (necessary)
		-src {source_file_path}
		//E.g. "-src ~/compress/data.bin"
	
	B. decompressed file path (optional)
		-dec {decompressed_file_path}
		//If decompressed file is not given, the program will use "{source_file_path}.cliz.bin" as the decompressed file path.
	
	C. dimension (optional)
		-dim {dimension_name}{dimansion_length} {dimension_name}{dimension_length} ...
		//Here inputs the dimensions indicating how the data should be interpreted.
		//{dimension_name} indicates the physical meaning of this dimension.
		//Current supported dimension names:
		//	t (time)
		//	h (height)
		//	lat (latitude)
		//	lng (longitude)
		//	/*leave out dimension name*/ (no meaning)
		//E.g. if given "-dim 12 t120 lat180 lng360", data[i0][i1][i2][i3]=data[i0*120*180*360+i1*180*360+i2*360+i3]
		//If the dimension is not given, the program will deduce the amount of data from the source file size and data type.

	D. data type (optional)
		-type {typename}
		//Here inputs the data type.
		//current supported {typename}:
		//	i32
		//	f32
		//	f64
		//	/*leave out data type*/ (f32)

	E. error bound (optional)
		-err {error_type} {error_bound}
		//Current supported error type:
		//	ABS
		//	REL
		//	LOCAL
		//	/*leave out error type*/ (ABS)
		//{error_bound} should be a value larger or equal to 0.
		//If error bound is 0 or not given, cliz validator will output the maximum absolute error.